#include "./types.h"

typedef struct {
    uint8_t limit_high : 4; // продолжение limit_low
    uint8_t flags : 4;      // флаги G, D/B, L, AVL
} __attribute__((packed)) gdt_granularity;

typedef struct {
    uint16_t limit_low; // указывает сколько памяти начиная с base может использовать процесс
    uint16_t base_low; // указывает адрес в памяти
    uint8_t base_middle; // продолжение base_low
    uint8_t access; // флаги p, dpl, s, type, (e, w) - type->3 = 0, (c, r) - type->3 = 1
    gdt_granularity granularity; 
    uint8_t base_high; // продолжение base_middle
} __attribute__((packed)) gdt_struct;

/*
    gdt_struct::access -
    0 бит>>accessed - cpu устанавливает
    Если 3 бит = 0, то
    1 бит>>expansion direction->cегмент растёт вверх (обычные данные)=0, cегмент растёт вниз (стек)=1
    2 бит>>writable->чтение=0, чтение и запись=1
    Иначе
    1 бит>>readable->только выполнение=0, можно читать=1
    2 бит>>сonforming->выполнение только с того же уровня ring=0, выполнение с других уровней ring=1

    3 бит>>executable->не исполняемый=0, исполняемый=1
    4 бит>>descriptor type->системный сигмент=0, обычный=1
    5-6 бит>>DPL(ring)->максимальные привилегии=00,ring 1=01, ring 2=10, минимальные привелегии=11
    7 бит>>present->сигмент отсуствует в памяти=0, присутствует=1

    gdt_granularity::flags -
    0 бит>>AVL->устанавливает ОС - обычно 0
    1 бит>>Long Mode->не 64-битный код=0, 64-битный код (используется в 64-битном режиме)=1
    Если для сегментов кода, то
    2 бит>>D/B->16-битные сегменты=0, 32-битные сегменты=1
    Иначе если для сегментов данных, то
    2 бит>>D/B->1 = используется SP (16-битный указатель стека)=0, используется ESP (32-битный указатель стека)=1
    Иначе если для нисходящих сегментов данных, то
    2 бит>>D/B->верхняя граница 64 КБ=0, верхняя граница 4 ГБ=1
    Иначе если Long Mode=1, то
    2 бит>>D/B->всегда 0

    3 бит>>granularity->лимит измеряется в байтах (1 байт)=0, лимит измеряется в страницах по 4КБ (4096 байт)=1
*/